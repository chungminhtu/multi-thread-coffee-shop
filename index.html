<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Coffee Shop Multithreading Visualization</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      margin: 20px;
    }

    table {
      border-collapse: collapse;
      width: auto;
      margin-bottom: 20px;
    }

    th,
    td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: center;
      font-size: 12px;
      width: 80px;
      min-width: 80px;
    }

    th {
      background-color: #d7d6d6;
      font-weight: bold;
    }

    .Take,
    .Brew,
    .Serve,
    .Process,
    .Assign,
    .Order,
    .Pay {
      background-color: #e6ffe6;
    }

    .Wait {
      background-color: #ffe6e6;
    }

    .Cache,
    .Receive {
      background-color: #e6e6ff;
    }

    #langSwitch {
      position: fixed;
      top: 10px;
      right: 10px;
      padding: 10px;
      background-color: #3498db;
      color: white;
      border: none;
      cursor: pointer;
    }

    img {
      max-width: 100%;
      height: auto;
      margin-bottom: 20px;
    }

    .explanation {
      font-family: "Merriweather", serif;
      font-weight: 400;
      font-style: normal;
      background-color: #f9f9f9;
      border-left: 5px solid #3498db;
      font-size: 16px !important;
      padding: 10px;
      margin-bottom: 20px;
    }
  </style>
</head>

<body>
  <button id="langSwitch">Switch to Vietnamese</button>
  <h1 id="main-title"></h1>
  <div id="scenarios"></div>

  <script>
    const data = {
      "title": {
        "en": "Multithreading in a Coffee Shop vs. Computer Processing (3 customers)",
        "vi": "Đa luồng trong Quán Cà phê so với Xử lý Máy tính (3 Khách)"
      },
      "scenarios": [
        {
          "title": {
            "en": "1. Synchronous Processing (Single-threaded processing)",
            "vi": "1. Xử lý Đồng bộ (Xử lý đơn luồng)"
          },
          "explanation": {
            "en": "Synchronous Processing: A sequential execution model where tasks are completed one after another. <br>In a coffee shop, this is like having one barista who must finish serving one customer entirely before moving to the next.  <br>In computer hardware, this corresponds to a single-core CPU executing instructions one at a time. In a coffee shop, if a customer orders a complex drink, all subsequent customers must wait.  <br>In Node.js, this would be like processing API requests one at a time, completing each request fully before moving to the next, which can lead to poor performance under high load.",
            "vi": "Xử lý Đồng bộ: Một mô hình thực thi tuần tự trong đó các tác vụ được hoàn thành lần lượt.  <br>Trong quán cà phê, điều này giống như có một barista phải phục vụ xong hoàn toàn một Khách trước khi chuyển sang Khách tiếp theo. Nếu một Khách đặt một đồ uống phức tạp, tất cả các Khách sau đó phải chờ đợi. <br>Trong phần cứng máy tính, điều này tương ứng với một CPU đơn lõi thực hiện các lệnh lần lượt. <br>Trong Node.js, điều này giống như xử lý các yêu cầu API từng cái một, hoàn thành mỗi yêu cầu đầy đủ trước khi chuyển sang yêu cầu tiếp theo, có thể dẫn đến hiệu suất kém trong điều kiện tải cao."
          },
          "subsections": [
            {
              "title": {
                "en": "1.1. Sequential Processing without Cache (One barista, one machine - Single CPU) - Total Time: 90 minutes",
                "vi": "1.1. Xử lý Tuần tự không có Bộ nhớ đệm (Một barista, một máy - CPU đơn) - Tổng thời gian: 90 phút"
              },
              "explanation": {
                "en": "Sequential Processing: A type of synchronous processing where each task is completed in full before moving to the next.  <br>In a coffee shop, this is like having one barista who must complete the entire order process for one customer before serving the next.  <br>In computer hardware, this is equivalent to a single CPU executing tasks one by one without any parallel processing or caching mechanisms. In a coffee shop scenario, if a customer orders a complex drink, all subsequent customers must wait, even if their orders are simple.  <br>In Node.js, this would be like using synchronous operations for everything, including I/O, which would block the event loop and prevent handling of other requests until each operation completes.",
                "vi": "Xử lý Tuần tự: Một loại xử lý đồng bộ trong đó mỗi tác vụ được hoàn thành đầy đủ trước khi chuyển sang tác vụ tiếp theo. <br> Trong quán cà phê, điều này giống như có một barista phải hoàn thành toàn bộ quy trình đặt hàng cho một Khách trước khi phục vụ Khách tiếp theo.  <br>Trong phần cứng máy tính, điều này tương đương với một CPU thực hiện các tác vụ lần lượt mà không có bất kỳ xử lý song song hoặc cơ chế bộ nhớ đệm nào. Trong kịch bản quán cà phê, nếu một Khách đặt một đồ uống phức tạp, tất cả các Khách sau đó phải chờ đợi, ngay cả khi đơn đặt hàng của họ đơn giản.  <br>Trong Node.js, điều này giống như sử dụng các hoạt động đồng bộ cho mọi thứ, bao gồm cả I/O, điều này sẽ chặn vòng lặp for loop và blocking xử lý các request khác cho đến khi mỗi hoạt động hoàn thành."
              },
              "image": "./assets//1.1.jpeg",
              "timeline": [
                {
                  "en": ["Customer 1", [["Take order", 10], ["Brew coffee", 10], ["Serve", 10]], 30],
                  "vi": ["Khách 1", [["Nhận đơn", 10], ["Pha cà phê", 10], ["Phục vụ", 10]], 30]
                },
                {
                  "en": ["Customer 2", [["Wait", 30], ["Take order", 10], ["Brew coffee", 10], ["Serve", 10]], 60],
                  "vi": ["Khách 2", [["Chờ đợi", 30], ["Nhận đơn", 10], ["Pha cà phê", 10], ["Phục vụ", 10]], 60]
                },
                {
                  "en": ["Customer 3", [["Wait", 60], ["Take order", 10], ["Brew coffee", 10], ["Serve", 10]], 90],
                  "vi": ["Khách 3", [["Chờ đợi", 60], ["Nhận đơn", 10], ["Pha cà phê", 10], ["Phục vụ", 10]], 90]
                }
              ]
            },
            {
              "title": {
                "en": "1.2. Processing with Caching (One barista, one machine, pre-prepared drinks - CPU with Fast Access to Stored Results) - Total Time: 40 minutes",
                "vi": "1.2. Xử lý với Bộ nhớ đệm (Một barista, một máy, đồ uống được chuẩn bị trước - CPU với Truy cập Nhanh vào Kết quả Đã lưu) - Tổng thời gian: 40 phút"
              },
              "explanation": {
                "en": "Caching: A technique of storing frequently requested data in a faster access memory to speed up subsequent retrievals. In a coffee shop, this is like pre-preparing popular drinks so they can be served quickly when ordered.  <br>In computing, this is similar to using CPU cache or RAM to store frequently accessed data, reducing the need to fetch it from slower storage.  <br>In a coffee shop scenario, the barista prepares a batch of the most popular drink in advance. When a customer orders this drink, it can be served immediately, significantly reducing wait times.  <br>In Node.js, caching can be implemented using in-memory stores like Redis or by keeping frequently accessed data in variables. For example, caching the results of database queries can significantly speed up repeated requests for the same data.",
                "vi": "Bộ nhớ đệm: Một kỹ thuật lưu trữ dữ liệu thường xuyên được yêu cầu trong bộ nhớ truy cập nhanh hơn để tăng tốc các lần truy xuất tiếp theo.  <br>Trong quán cà phê, điều này giống như chuẩn bị trước các đồ uống phổ biến để có thể phục vụ nhanh chóng khi được đặt hàng. Trong máy tính, điều này tương tự như sử dụng bộ nhớ đệm CPU hoặc RAM để lưu trữ dữ liệu thường xuyên truy cập, giảm nhu cầu lấy dữ liệu từ bộ nhớ chậm hơn.  <br>Trong kịch bản quán cà phê, barista chuẩn bị trước một lô đồ uống phổ biến nhất. Khi một Khách đặt đồ uống này, nó có thể được phục vụ ngay lập tức, giảm đáng kể thời gian chờ đợi.  <br>Trong Node.js, việc lưu trữ bộ nhớ đệm có thể được thực hiện bằng cách sử dụng các kho lưu trữ trong bộ nhớ như Redis hoặc lưu dữ liệu thường xuyên truy cập trong các variable (RAM). Ví dụ, lưu trữ kết quả của các truy vấn cơ sở dữ liệu trong bộ nhớ đệm có thể tăng tốc đáng kể các yêu cầu lặp lại cho cùng một dữ liệu."
              },
              "image": "./assets//1.2.jpeg",
              "timeline": [
                {
                  "en": ["Customer 1", [["Take order", 5], ["Brew new", 15], ["Serve", 5], ["Cache", 5]], 30],
                  "vi": ["Khách 1", [["Nhận đơn", 5], ["Pha mới", 15], ["Phục vụ", 5], ["Lưu cache", 5]], 30]
                },
                {
                  "en": ["Customer 2", [["Wait", 25], ["Take order", 3], ["Serve from Cache", 2]], 35],
                  "vi": ["Khách 2", [["Chờ đợi", 25], ["Nhận đơn", 3], ["Phục vụ từ Cache", 2]], 35]
                },
                {
                  "en": ["Customer 3", [["Wait", 30], ["Take order", 3], ["Serve from Cache", 2]], 40],
                  "vi": ["Khách 3", [["Chờ đợi", 30], ["Nhận đơn", 3], ["Phục vụ từ Cache", 2]], 40]
                }
              ]
            }
          ]
        },
        {
          "title": {
            "en": "2. Asynchronous Processing",
            "vi": "2. Xử lý Bất đồng bộ"
          },
          "explanation": {
            "en": "Asynchronous Processing: An execution model where multiple tasks can be handled simultaneously without waiting for each other to complete. In a coffee shop, this is like having multiple baristas or one barista multitasking, starting new orders before previous ones are completed. While waiting for an espresso machine to finish, a barista can take another order or prepare a cold drink.This efficient use of time reduces overall wait times and increases throughput. <br>In computing, this can be achieved through various means such as multi-core processors, hyperthreading, or I/O operations that don't block the main thread.   <br>   In Node.js, asynchronous processing is fundamental to its architecture.It uses an event- driven, non- blocking I/O model.For example, when making a database query, Node.js doesn't wait for the query to complete before moving on. Instead, it continues executing other code and uses callbacks or promises to handle the query result when it's ready.This allows Node.js to handle many concurrent operations efficiently, similar to how a skilled barista can manage multiple orders simultaneously.",
            "vi": "Xử lý Bất đồng bộ: Một mô hình thực thi trong đó nhiều tác vụ có thể được xử lý đồng thời mà không cần chờ đợi nhau hoàn thành. Trong quán cà phê, điều này giống như có nhiều barista hoặc một barista đa nhiệm, bắt đầu các đơn hàng mới trước khi các đơn hàng trước đó hoàn thành. Trong khi chờ máy pha espresso hoàn thành, một barista có thể nhận đơn hàng khác hoặc chuẩn bị đồ uống lạnh.Việc sử dụng thời gian hiệu quả này giảm thời gian chờ đợi tổng thể và tăng tốc độ phục vụ. <br> Trong phần cứng máy tính, điều này có thể đạt được thông qua nhiều phương tiện như bộ xử lý đa lõi, siêu phân luồng, hoặc các hoạt động I/O không chặn luồng chính.  <br>Trong Node.js, xử lý bất đồng bộ là nền tảng của kiến trúc của nó.Nó sử dụng mô hình I/O không chặn, hướng sự kiện.Ví dụ, khi thực hiện một truy vấn cơ sở dữ liệu, Node.js không chờ đợi truy vấn hoàn thành trước khi tiếp tục.Thay vào đó, nó tiếp tục thực thi mã khác và sử dụng callbacks hoặc promises để xử lý kết quả truy vấn khi sẵn sàng.Điều này cho phép Node.js xử lý nhiều hoạt động đồng thời một cách hiệu quả, tương tự như cách một barista lành nghề có thể quản lý nhiều đơn hàng cùng một lúc."
          },
          "subsections": [
            {
              "title": {
                "en": "2.1 Concurrent Processing (One multi-tasking barista, single machine - Single CPU with Context Switching)",
                "vi": "2.1 Xử lý Đồng thời (Một barista đa nhiệm, một máy - CPU đơn với Chuyển đổi Ngữ cảnh)"
              },
              "explanation": {
                "en": "Concurrent Processing: A form of computing where multiple tasks are executed during overlapping time periods, but not necessarily simultaneously. In a coffee shop, this is like a single barista juggling multiple orders at once, switching between tasks rapidly. In computing, this can be achieved through context switching on a single CPU core, giving the illusion of parallelism. <br>  In a coffee shop, a single barista might start brewing an espresso, then while waiting for it to finish, begin preparing a cold brew.They switch back to the espresso when it's ready, then return to finishing the cold brew. This approach maximizes the barista's productivity. <br>  In Node.js, the event loop handles concurrent operations.While it's single-threaded, it can manage multiple operations concurrently by delegating I/O operations to the system kernel whenever possible. For example, when reading a file, Node.js initiates the read operation and then continues executing other code. When the file read is complete, a callback is triggered to handle the result.",
                "vi": "Xử lý Đồng thời: Một hình thức tính toán trong đó nhiều tác vụ được thực hiện trong các khoảng thời gian chồng chéo, nhưng không nhất thiết phải đồng thời. Trong quán cà phê, điều này giống như một barista duy nhất xử lý nhiều đơn hàng cùng một lúc, chuyển đổi nhanh chóng giữa các tác vụ. Một barista duy nhất có thể bắt đầu pha espresso, sau đó trong khi chờ đợi nó hoàn thành, bắt đầu chuẩn bị cà phê lạnh.Họ chuyển lại sang espresso khi nó sẵn sàng, sau đó quay lại hoàn thành cà phê lạnh.Cách tiếp cận này tối đa hóa năng suất của barista. <br> Trong máy tính, điều này có thể đạt được thông qua chuyển đổi ngữ cảnh trên một lõi CPU duy nhất, tạo ra ảo giác của sự song song. <br> Trong Node.js, vòng lặp sự kiện xử lý các hoạt động đồng thời.Mặc dù nó là đơn luồng, nó có thể quản lý nhiều hoạt động đồng thời bằng cách ủy quyền các hoạt động I/ O cho kernel hệ thống khi có thể.Ví dụ, khi đọc một tệp, Node.js khởi tạo hoạt động đọc và sau đó tiếp tục thực thi mã khác.Khi việc đọc tệp hoàn tất, một callback được kích hoạt để xử lý kết quả."
              },
              "subsubsections": [
                {
                  "title": {
                    "en": "2.1.1 One multitasking barista - Time slicing (Single CPU with Rapid Task Switching) - Total Time: 60 minutes",
                    "vi": "2.1.1 Một barista đa nhiệm - Chia thời gian (CPU đơn với Chuyển đổi Tác vụ Nhanh) - Tổng thời gian: 60 phút"
                  },
                  "explanation": {
                    "en": "Time-Slicing: A technique where a single processor switches between multiple tasks, giving each task a small amount of time before moving to the next. In a coffee shop, this is like a barista who works on each customer's order for a short time before moving to the next, cycling through all orders. <br>      In the coffee shop, the barista might froth milk for one order for 30 seconds, then switch to grinding beans for another order for 30 seconds, and so on, cycling through all active orders. <br>      In Node.js, the event loop implements a form of time- slicing.It cycles through different phases, each handling specific types of callbacks.This allows Node.js to give attention to various tasks in a round- robin fashion, ensuring that no single operation blocks the entire application.",
                    "vi": "Chia thời gian: Một kỹ thuật trong đó một bộ xử lý đơn chuyển đổi giữa nhiều tác vụ, cho mỗi tác vụ một lượng thời gian nhỏ trước khi chuyển sang tác vụ tiếp theo. Trong quán cà phê, điều này giống như một barista làm việc trên đơn hàng của mỗi khách hàng trong một thời gian ngắn trước khi chuyển sang khách hàng tiếp theo, xoay vòng qua tất cả các đơn hàng. <br>      Trong quán cà phê, barista có thể đánh sữa cho một đơn hàng trong 30 giây, sau đó chuyển sang xay hạt cho đơn hàng khác trong 30 giây, và cứ tiếp tục như vậy, xoay vòng qua tất cả các đơn hàng đang hoạt động. <br>      Trong Node.js, vòng lặp sự kiện thực hiện một hình thức chia thời gian.Nó xoay vòng qua các giai đoạn khác nhau, mỗi giai đoạn xử lý các loại callbacks cụ thể.Điều này cho phép Node.js chú ý đến các tác vụ khác nhau theo kiểu round - robin, đảm bảo rằng không có hoạt động đơn lẻ nào chặn toàn bộ ứng dụng."
                  },
                  "image": "./assets//2.1.1.jpeg",
                  "timeline": [
                    {
                      "en": ["Customer 1", [["Take order", 10], ["Start brewing", 10], ["Wait", 15], ["Serve", 5]], 40],
                      "vi": ["Khách 1", [["Nhận đơn", 10], ["Bắt đầu pha", 10], ["Chờ đợi", 15], ["Phục vụ", 5]], 40]
                    },
                    {
                      "en": ["Customer 2", [["Wait", 5], ["Take order", 10], ["Start brewing", 10], ["Wait", 20], ["Serve", 5]], 50],
                      "vi": ["Khách 2", [["Chờ đợi", 5], ["Nhận đơn", 10], ["Bắt đầu pha", 10], ["Chờ đợi", 20], ["Phục vụ", 5]], 50]
                    },
                    {
                      "en": ["Customer 3", [["Wait", 10], ["Take order", 10], ["Start brewing", 10], ["Wait", 25], ["Serve", 5]], 60],
                      "vi": ["Khách 3", [["Chờ đợi", 10], ["Nhận đơn", 10], ["Bắt đầu pha", 10], ["Chờ đợi", 25], ["Phục vụ", 5]], 60]
                    }
                  ]
                },
                {
                  "title": {
                    "en": "2.1.2 Multi-Threading (Multiple baristas, single machine - Single CPU with Multiple Execution Threads) - Total Time: 45 minutes",
                    "vi": "2.1.2 Đa luồng (Nhiều barista, một máy - CPU đơn với Nhiều Luồng Thực thi) - Tổng thời gian: 45 phút"
                  },
                  "explanation": {
                    "en": "Multi-Threading: A programming concept where multiple threads (lightweight processes) run concurrently within a single process, sharing the same resources but executing independently. In a coffee shop, this is like having multiple baristas working on different orders but sharing one coffee machine. <br>      In the coffee shop, one barista might be taking orders while another prepares drinks, but they need to coordinate when using the shared coffee machine. <br>      In Node.js, while the main JavaScript execution is single- threaded, it uses multiple threads behind the scenes for certain operations.For example, the libuv library used by Node.js employs a thread pool for handling file I/ O and some cryptographic operations, allowing these potentially blocking operations to run concurrently with the main event loop.",
                    "vi": "Đa luồng: Một khái niệm lập trình trong đó nhiều luồng (các tiến trình nhẹ) chạy đồng thời trong một tiến trình duy nhất, chia sẻ cùng tài nguyên nhưng thực thi độc lập. Trong quán cà phê, điều này giống như có nhiều barista làm việc trên các đơn hàng khác nhau nhưng chia sẻ một máy pha cà phê. <br>      Trong quán cà phê, một barista có thể đang nhận đơn hàng trong khi barista khác chuẩn bị đồ uống, nhưng họ cần phối hợp khi sử dụng máy pha cà phê chung. <br>      Trong Node.js, mặc dù việc thực thi JavaScript chính là đơn luồng, nó sử dụng nhiều luồng ẩn cho một số hoạt động nhất định.Ví dụ, thư viện libuv được sử dụng bởi Node.js sử dụng một nhóm luồng để xử lý I/O tệp và một số hoạt động mã hóa, cho phép các hoạt động có thể chặn này chạy đồng thời với vòng lặp sự kiện chính."
                  },
                  "image": "./assets//2.1.2.jpeg",
                  "timeline": [
                    {
                      "en": ["Barista 1", [["Take order 1", 5], ["Wait for machine", 5], ["Brew 1", 10], ["Serve 1", 5]], 25],
                      "vi": ["Barista 1", [["Nhận đơn 1", 5], ["Chờ máy", 5], ["Pha 1", 10], ["Phục vụ 1", 5]], 25]
                    },
                    {
                      "en": ["Barista 2", [["Take order 2", 5], ["Wait", 10], ["Use machine", 5], ["Brew 2", 5], ["Serve 2", 5]], 30],
                      "vi": ["Barista 2", [["Nhận đơn 2", 5], ["Chờ đợi", 10], ["Sử dụng máy", 5], ["Pha 2", 5], ["Phục vụ 2", 5]], 30]
                    },
                    {
                      "en": ["Barista 3", [["Take order 3", 5], ["Wait", 20], ["Use machine", 5], ["Brew 3", 10], ["Serve 3", 5]], 45],
                      "vi": ["Barista 3", [["Nhận đơn 3", 5], ["Chờ đợi", 20], ["Sử dụng máy", 5], ["Pha 3", 10], ["Phục vụ 3", 5]], 45]
                    }
                  ]
                },
                {
                  "title": {
                    "en": "2.1.3 Producer-Consumer (Separate order taker and barista - Single CPU with Input Queue and Processor) - Total Time: 45 minutes",
                    "vi": "2.1.3 Người sản xuất-Người tiêu dùng (Người nhận đơn và barista riêng biệt - CPU đơn với Hàng đợi Đầu vào và Bộ xử lý) - Tổng thời gian: 45 phút"
                  },
                  "explanation": {
                    "en": "Producer-Consumer: A programming pattern where one part of the code generates data (the producer) and another part processes it (the consumer). In a coffee shop, this is like having a dedicated order taker who queues up orders for the barista to process. <br>      In the coffee shop, the cashier(producer) takes orders and puts them in a queue, while the barista(consumer) picks up orders from the queue and prepares them.This allows for efficient division of labor and smooth workflow. <br>      In Node.js, this pattern is often implemented using event emitters or message queues.For example, a web server (producer) might receive HTTP requests and add them to a queue, while worker processes(consumers) pick up these requests from the queue and process them.This allows for better load balancing and scalability in high - traffic applications.",
                    "vi": "Người sản xuất-Người tiêu dùng: Một mẫu lập trình trong đó một phần của mã tạo ra dữ liệu (người sản xuất) và một phần khác xử lý nó (người tiêu dùng). Trong quán cà phê, điều này giống như có một người nhận đơn hàng chuyên dụng xếp hàng đợi các đơn hàng để barista xử lý. <br>      Trong quán cà phê, thu ngân(người sản xuất) nhận đơn hàng và đưa chúng vào hàng đợi, trong khi barista(người tiêu dùng) lấy đơn hàng từ hàng đợi và chuẩn bị chúng.Điều này cho phép phân chia công việc hiệu quả và quy trình làm việc suôn sẻ. <br>      Trong Node.js, mẫu này thường được triển khai bằng cách sử dụng event emitters hoặc hàng đợi tin nhắn.Ví dụ, một máy chủ web(người sản xuất) có thể nhận các yêu cầu HTTP và thêm chúng vào hàng đợi, trong khi các quy trình worker(người tiêu dùng) lấy các yêu cầu này từ hàng đợi và xử lý chúng.Điều này cho phép cân bằng tải và khả năng mở rộng tốt hơn trong các ứng dụng có lưu lượng truy cập cao."
                  },
                  "image": "./assets//2.1.3.jpeg",
                  "timeline": [
                    {
                      "en": ["Order Taker", [["Take order 1", 5], ["Take order 2", 5], ["Take order 3", 5]], 15],
                      "vi": ["Người nhận đơn", [["Nhận đơn 1", 5], ["Nhận đơn 2", 5], ["Nhận đơn 3", 5]], 15]
                    },
                    {
                      "en": ["Barista", [["Wait", 5], ["Brew coffee 1", 10], ["Brew coffee 2", 10], ["Brew coffee 3", 10]], 35],
                      "vi": ["Barista", [["Chờ đợi", 5], ["Pha cà phê 1", 10], ["Pha cà phê 2", 10], ["Pha cà phê 3", 10]], 35]
                    },
                    {
                      "en": ["Serving", [["Wait", 25], ["Serve 1", 5], ["Serve 2", 5], ["Serve 3", 5]], 40],
                      "vi": ["Phục vụ", [["Chờ đợi", 25], ["Phục vụ 1", 5], ["Phục vụ 2", 5], ["Phục vụ 3", 5]], 40]
                    },
                    {
                      "en": ["Customer 1", [["Order", 5], ["Wait", 25], ["Receive", 5]], 35],
                      "vi": ["Khách 1", [["Đặt hàng", 5], ["Chờ đợi", 25], ["Nhận", 5]], 35]
                    },
                    {
                      "en": ["Customer 2", [["Wait", 5], ["Order", 5], ["Wait", 25], ["Receive", 5]], 40],
                      "vi": ["Khách 2", [["Chờ đợi", 5], ["Đặt hàng", 5], ["Chờ đợi", 25], ["Nhận", 5]], 40]
                    },
                    {
                      "en": ["Customer 3", [["Wait", 10], ["Order", 5], ["Wait", 25], ["Receive", 5]], 45],
                      "vi": ["Khách 3", [["Chờ đợi", 10], ["Đặt hàng", 5], ["Chờ đợi", 25], ["Nhận", 5]], 45]
                    }
                  ]
                }
              ]
            },
            {
              "title": {
                "en": "2.2 Parallel Processing (Multiple baristas, multiple machines - Multiple CPUs) - Total Time: 30 minutes",
                "vi": "2.2 Xử lý Song song (Nhiều barista, nhiều máy - Nhiều CPU) - Tổng thời gian: 30 phút"
              },
              "explanation": {
                "en": "Parallel Processing: A type of computation where many calculations or executions are carried out simultaneously. In a coffee shop, this is like having multiple baristas, each with their own coffee machine, serving customers independently. <br>  In the coffee shop, three baristas can simultaneously prepare three different orders, significantly reducing the overall waiting time for customers. <br>  In computing, parallel processing is achieved through multi - core processors or distributed systems.In Node.js, while the main JavaScript execution is single - threaded, you can leverage parallel processing using child processes or worker threads.For CPU-intensive tasks, you can spawn multiple worker threads, each running on a separate CPU core, to perform calculations in parallel.",
                "vi": "Xử lý Song song: Một loại tính toán trong đó nhiều phép tính hoặc thực thi được thực hiện đồng thời. Trong quán cà phê, điều này giống như có nhiều barista, mỗi người có máy pha cà phê riêng, phục vụ khách hàng độc lập. <br>  Trong quán cà phê, ba barista có thể đồng thời chuẩn bị ba đơn hàng khác nhau, giảm đáng kể thời gian chờ đợi tổng thể cho khách hàng. <br>  Trong máy tính, xử lý song song được thực hiện thông qua bộ xử lý đa lõi hoặc hệ thống phân tán.Trong Node.js, mặc dù việc thực thi JavaScript chính là đơn luồng, bạn có thể tận dụng xử lý song song bằng cách sử dụng các tiến trình con hoặc luồng worker.Đối với các tác vụ đòi hỏi nhiều CPU, bạn có thể tạo ra nhiều luồng worker, mỗi luồng chạy trên một lõi CPU riêng biệt, để thực hiện các tính toán song song."
              },
              "image": "./assets//2.2.jpeg",
              "timeline": [
                {
                  "en": ["Barista 1", [["Take order", 5], ["Brew coffee at Espresso Machine", 20], ["Serve Customer 1", 5]], 30],
                  "vi": ["Barista 1", [["Nhận đơn", 5], ["Pha cà phê tại Máy Espresso", 20], ["Phục vụ Khách 1", 5]], 30]
                },
                {
                  "en": ["Barista 2", [["Take order", 5], ["Brew coffee at Drip Coffee Maker", 20], ["Serve Customer 2", 5]], 30],
                  "vi": ["Barista 2", [["Nhận đơn", 5], ["Pha cà phê tại Máy pha cà phê nhỏ giọt", 20], ["Phục vụ Khách 2", 5]], 30]
                },
                {
                  "en": ["Barista 3", [["Take order", 5], ["Brew coffee at Tea Maker Machine", 20], ["Serve Customer 3", 5]], 30],
                  "vi": ["Barista 3", [["Nhận đơn", 5], ["Pha cà phê tại Máy pha trà", 20], ["Phục vụ Khách 3", 5]], 30]
                }
              ]
            },
            {
              "title": {
                "en": "2.3 Microservices (Specialized coffee stations - Distributed CPUs with Specialized Services) - Total Time: 35 minutes",
                "vi": "2.3 Microservices (Các trạm cà phê chuyên biệt - Các CPU phân tán với Dịch vụ Chuyên biệt) - Tổng thời gian: 35 phút"
              },
              "explanation": {
                "en": "Microservices: An architectural style that structures an application as a collection of loosely coupled services. In a coffee shop, this is like having separate stations for ordering, payment, different types of coffee preparation, and serving. <br>  In the coffee shop, there might be a dedicated order station, a payment station, separate machines for espresso, drip coffee, and tea, and a serving station.Each station operates independently but communicates with others to complete orders. <br>  In software architecture, microservices allow different parts of an application to be developed, deployed, and scaled independently.In a Node.js ecosystem, you might have separate services for user authentication, product catalog, order processing, and payment handling.Each service can be written in Node.js or even different languages, communicating via APIs, often using lightweight protocols like HTTP/REST or message queues.",
                "vi": "Microservices: Một phong cách kiến trúc cấu trúc một ứng dụng như một tập hợp các dịch vụ liên kết lỏng lẻo. Trong quán cà phê, điều này giống như có các trạm riêng biệt để đặt hàng, thanh toán, chuẩn bị các loại cà phê khác nhau và phục vụ. <br>  Trong quán cà phê, có thể có một trạm đặt hàng chuyên dụng, một trạm thanh toán, các máy riêng biệt cho espresso, cà phê nhỏ giọt và trà, và một trạm phục vụ.Mỗi trạm hoạt động độc lập nhưng giao tiếp với nhau để hoàn thành đơn hàng. <br>  Trong kiến trúc phần mềm, microservices cho phép các phần khác nhau của một ứng dụng được phát triển, triển khai và mở rộng độc lập.Trong hệ sinh thái Node.js, bạn có thể có các dịch vụ riêng biệt cho xác thực người dùng, danh mục sản phẩm, xử lý đơn hàng và xử lý thanh toán.Mỗi dịch vụ có thể được viết bằng Node.js hoặc thậm chí các ngôn ngữ khác nhau, giao tiếp thông qua API, thường sử dụng các giao thức nhẹ như HTTP / REST hoặc hàng đợi tin nhắn."
              },
              "image": "./assets//2.3.jpeg",
              "timeline": [
                {
                  "en": ["Order Station", [["Take order 1", 5], ["Take order 2", 5], ["Take order 3", 5]], 15],
                  "vi": ["Trạm đặt hàng", [["Nhận đơn 1", 5], ["Nhận đơn 2", 5], ["Nhận đơn 3", 5]], 15]
                },
                {
                  "en": ["Payment Station", [["Process payment 1", 5], ["Process payment 2", 5], ["Process payment 3", 5]], 15],
                  "vi": ["Trạm thanh toán", [["Xử lý thanh toán 1", 5], ["Xử lý thanh toán 2", 5], ["Xử lý thanh toán 3", 5]], 15]
                },
                {
                  "en": ["Espresso Machine", [["Wait", 5], ["Brew Espresso 1", 10]], 15],
                  "vi": ["Máy Espresso", [["Chờ đợi", 5], ["Pha Espresso 1", 10]], 15]
                },
                {
                  "en": ["Drip Coffee Maker", [["Wait", 10], ["Brew drip coffee 2", 10]], 20],
                  "vi": ["Máy pha cà phê nhỏ giọt", [["Chờ đợi", 10], ["Pha cà phê nhỏ giọt 2", 10]], 20]
                },
                {
                  "en": ["Tea Station", [["Wait", 15], ["Brew tea 3", 10]], 25],
                  "vi": ["Trạm trà", [["Chờ đợi", 15], ["Pha trà 3", 10]], 25]
                },
                {
                  "en": ["Serving Station", [["Wait", 20], ["Serve 1", 3], ["Serve 2", 3], ["Serve 3", 3]], 34],
                  "vi": ["Trạm phục vụ", [["Chờ đợi", 20], ["Phục vụ 1", 3], ["Phục vụ 2", 3], ["Phục vụ 3", 3]], 34]
                },
                {
                  "en": ["Customer 1", [["Order", 5], ["Pay", 5], ["Wait Espresso", 10], ["Receive", 5]], 25],
                  "vi": ["Khách 1", [["Đặt hàng", 5], ["Thanh toán", 5], ["Chờ Espresso", 10], ["Nhận", 5]], 25]
                },
                {
                  "en": ["Customer 2", [["Wait", 5], ["Order", 5], ["Pay", 5], ["Wait drip coffee", 10], ["Receive", 5]], 30],
                  "vi": ["Khách 2", [["Chờ đợi", 5], ["Đặt hàng", 5], ["Thanh toán", 5], ["Chờ cà phê nhỏ giọt", 10], ["Nhận", 5]], 30]
                },
                {
                  "en": ["Customer 3", [["Wait", 10], ["Order", 5], ["Pay", 5], ["Wait tea", 10], ["Receive", 5]], 35],
                  "vi": ["Khách 3", [["Chờ đợi", 10], ["Đặt hàng", 5], ["Thanh toán", 5], ["Chờ trà", 10], ["Nhận", 5]], 35]
                }
              ]
            },
            {
              "title": {
                "en": "2.4 Distributed Processing (Multiple coffee shops - Multiple CPUs in Different Locations) - Total Time: 30 minutes",
                "vi": "2.4 Xử lý Phân tán (Nhiều quán cà phê - Nhiều CPU ở Các Vị trí Khác nhau) - Tổng thời gian: 30 phút"
              },
              "explanation": {
                "en": "Distributed Processing: A method of computing where multiple interconnected computers work together to solve a problem. In a coffee shop analogy, this is like having separate coffee shops, each handling its own customers, but all part of the same chain. <br>  In the coffee shop scenario, three different shops in various locations can each serve a customer simultaneously, effectively tripling the serving capacity of the business. <br>  In computing, distributed processing allows for massive scalability and fault tolerance.In a Node.js context, you might use a cluster of servers running Node.js applications, coordinated by a load balancer.Each server could handle a portion of the incoming requests, with data being shared and synchronized across the cluster.Technologies like Redis for distributed caching or Apache Kafka for distributed streaming can be used in conjunction with Node.js to build robust distributed systems.",
                "vi": "Xử lý Phân tán: Một phương pháp tính toán trong đó nhiều máy tính được kết nối làm việc cùng nhau để giải quyết một vấn đề. Trong ví dụ về quán cà phê, điều này giống như có nhiều quán cà phê riêng biệt, mỗi quán xử lý khách hàng của riêng mình, nhưng tất cả đều là một phần của cùng một chuỗi. <br>  Trong kịch bản quán cà phê, ba cửa hàng khác nhau ở các vị trí khác nhau có thể phục vụ đồng thời một khách hàng, hiệu quả là tăng gấp ba lần khả năng phục vụ của doanh nghiệp. <br>  Trong máy tính, xử lý phân tán cho phép khả năng mở rộng và chịu lỗi lớn.Trong bối cảnh Node.js, bạn có thể sử dụng một cụm máy chủ chạy các ứng dụng Node.js, được điều phối bởi một bộ cân bằng tải.Mỗi máy chủ có thể xử lý một phần của các yêu cầu đến, với dữ liệu được chia sẻ và đồng bộ hóa trên toàn cụm.Các công nghệ như Redis để lưu trữ bộ nhớ đệm phân tán hoặc Apache Kafka để truyền dữ liệu phân tán có thể được sử dụng kết hợp với Node.js để xây dựng các hệ thống phân tán mạnh mẽ."
              },
              "image": "./assets//2.4.jpeg",
              "timeline": [
                {
                  "en": ["Shop 1", [["Take order", 5], ["Brew coffee", 20], ["Serve Customer 1", 5]], 30],
                  "vi": ["Cửa hàng 1", [["Nhận đơn", 5], ["Pha cà phê", 20], ["Phục vụ Khách 1", 5]], 30]
                },
                {
                  "en": ["Shop 2", [["Take order", 5], ["Brew coffee", 20], ["Serve Customer 2", 5]], 30],
                  "vi": ["Cửa hàng 2", [["Nhận đơn", 5], ["Pha cà phê", 20], ["Phục vụ Khách 2", 5]], 30]
                },
                {
                  "en": ["Shop 3", [["Take order", 5], ["Brew coffee", 20], ["Serve Customer 3", 5]], 30],
                  "vi": ["Cửa hàng 3", [["Nhận đơn", 5], ["Pha cà phê", 20], ["Phục vụ Khách 3", 5]], 30]
                }
              ]
            },
            {
              "title": {
                "en": "2.5 Load Balancing (Efficient customer assignment with dynamic scaling - Multiple CPUs with Task Distribution) - Total Time: 30 minutes",
                "vi": "2.5 Cân bằng Tải (Phân công Khách hiệu quả với mở rộng động - Nhiều CPU với Phân phối Tác vụ) - Tổng thời gian: 30 phút"
              },
              "explanation": {
                "en": "Load Balancing: A technique used to distribute workloads across multiple computing resources. In a coffee shop, this would be like having a manager who assigns customers to different baristas based on their current workload. When all baristas are busy, a new barista is hired to handle additional customers, demonstrating dynamic scaling. <br>  In the coffee shop scenario, a manager(load balancer) assigns incoming customers to available baristas, ensuring efficient use of resources and minimizing wait times.If all baristas become busy, a new one is quickly brought in to help. <br>  In computing, load balancing is crucial for high - traffic applications.In a Node.js environment, you might use a reverse proxy like Nginx as a load balancer to distribute incoming HTTP requests across multiple Node.js server instances.For more complex scenarios, you could use dedicated load balancing solutions like HAProxy or cloud - based load balancers.These systems can also perform health checks on your servers and automatically route traffic away from failing instances, improving the overall reliability of your application.",
                "vi": "Cân bằng Tải: Một kỹ thuật được sử dụng để phân phối khối lượng công việc trên nhiều tài nguyên tính toán. Trong quán cà phê, điều này giống như có một người quản lý phân công khách hàng cho các barista khác nhau dựa trên khối lượng công việc hiện tại của họ. Khi tất cả các barista đều bận rộn, một barista mới được thuê để xử lý khách hàng bổ sung, thể hiện khả năng mở rộng động. <br>  Trong kịch bản quán cà phê, một người quản lý(bộ cân bằng tải) phân công khách hàng đến cho các barista có sẵn, đảm bảo sử dụng hiệu quả tài nguyên và giảm thiểu thời gian chờ đợi.Nếu tất cả các barista trở nên bận rộn, một người mới nhanh chóng được đưa vào để giúp đỡ. <br>  Trong máy tính, cân bằng tải rất quan trọng đối với các ứng dụng có lưu lượng truy cập cao.Trong môi trường Node.js, bạn có thể sử dụng một reverse proxy như Nginx làm bộ cân bằng tải để phân phối các yêu cầu HTTP đến trên nhiều phiên bản máy chủ Node.js.Đối với các kịch bản phức tạp hơn, bạn có thể sử dụng các giải pháp cân bằng tải chuyên dụng như HAProxy hoặc bộ cân bằng tải dựa trên đám mây.Các hệ thống này cũng có thể thực hiện kiểm tra sức khỏe trên các máy chủ của bạn và tự động chuyển hướng lưu lượng truy cập khỏi các phiên bản đang gặp sự cố, cải thiện độ tin cậy tổng thể của ứng dụng của bạn."
              },
              "image": "./assets//2.5.jpeg",
              "timeline": [
                {
                  "en": ["Load Balancer", [["Assign Customer 1", 1], ["Assign Customer 2", 1], ["Assign Customer 3", 1], ["Hire New Barista", 2]], 5],
                  "vi": ["Bộ cân bằng tải", [["Phân công Khách 1", 1], ["Phân công Khách 2", 1], ["Phân công Khách 3", 1], ["Thuê Barista Mới", 2]], 5]
                },
                {
                  "en": ["Barista 1", [["Take order", 5], ["Brew coffee", 15], ["Serve", 5]], 25],
                  "vi": ["Barista 1", [["Nhận đơn", 5], ["Pha cà phê", 15], ["Phục vụ", 5]], 25]
                },
                {
                  "en": ["Barista 2", [["Take order", 5], ["Brew coffee", 15], ["Serve", 5]], 25],
                  "vi": ["Barista 2", [["Nhận đơn", 5], ["Pha cà phê", 15], ["Phục vụ", 5]], 25]
                },
                {
                  "en": ["Barista 3", [["Take order", 5], ["Brew coffee", 15], ["Serve", 5]], 25],
                  "vi": ["Barista 3", [["Nhận đơn", 5], ["Pha cà phê", 15], ["Phục vụ", 5]], 25]
                },
                {
                  "en": ["New Barista", [["Wait", 5], ["Take order", 5], ["Brew coffee", 15], ["Serve", 5]], 30],
                  "vi": ["Barista Mới", [["Chờ đợi", 5], ["Nhận đơn", 5], ["Pha cà phê", 15], ["Phục vụ", 5]], 30]
                }
              ]
            }
          ]
        }
      ]
    };

    let currentLang = 'en';


    function createTimelineTable(timelines) {
      const table = document.createElement('table');
      const thead = document.createElement('thead');
      const tbody = document.createElement('tbody');
      const headerRow = document.createElement('tr');

      const totalTime = Math.max(...timelines.map(t => t[currentLang][2]));

      // Action keywords that should be colored green
      const greenActions = {
        'en': ['take order', 'brew', 'serve'],
        'vi': ['nhận đơn', 'pha', 'phục vụ']
      };

      // Create header row
      const timelineHeader = document.createElement('th');
      timelineHeader.textContent = currentLang === 'en' ? 'Timeline' : 'Thời gian';
      headerRow.appendChild(timelineHeader);

      for (let i = 5; i <= totalTime; i += 5) {
        const th = document.createElement('th');
        th.textContent = i;
        headerRow.appendChild(th);
      }
      thead.appendChild(headerRow);
      table.appendChild(thead);

      // Create rows for each timeline
      timelines.forEach(timeline => {
        const row = document.createElement('tr');
        const labelCell = document.createElement('td');
        labelCell.textContent = timeline[currentLang][0];
        row.appendChild(labelCell);

        let currentTime = 0;
        timeline[currentLang][1].forEach((event, index) => {
          const [action, duration] = event;
          const cell = document.createElement('td');
          cell.textContent = action;

          // Color the cell based on the action
          if (greenActions[currentLang].some(keyword => action.toLowerCase().includes(keyword))) {
            cell.style.backgroundColor = '#90EE90'; // Light green
          } else {
            cell.style.backgroundColor = '#D2B48C'; // Light brown (tan)
          }

          cell.colSpan = duration / 5;
          row.appendChild(cell);
          currentTime += duration;
        });

        // Fill remaining time with empty cells if necessary
        if (currentTime < totalTime) {
          const emptyCell = document.createElement('td');
          emptyCell.colSpan = (totalTime - currentTime) / 5;
          row.appendChild(emptyCell);
        }

        tbody.appendChild(row);
      });

      const totalRow = document.createElement('tr');
      const totalLabelCell = document.createElement('td');
      totalLabelCell.textContent = currentLang === 'en' ? 'Total Time' : 'Tổng';
      totalRow.appendChild(totalLabelCell);

      const totalTimeCell = document.createElement('td');
      totalTimeCell.colSpan = totalTime / 5;
      totalTimeCell.textContent = currentLang === 'en' ? `${totalTime} minutes` : `${totalTime} phút`;
      totalTimeCell.style.fontWeight = 'bold';
      totalRow.appendChild(totalTimeCell);

      tbody.appendChild(totalRow);

      table.appendChild(tbody);
      return table;
    }



    function renderScenario(scenario, container) {
      const h2 = document.createElement('h2');
      h2.textContent = scenario.title[currentLang];
      container.appendChild(h2);

      const explanation = document.createElement('div');
      explanation.className = 'explanation';
      explanation.innerHTML = scenario.explanation[currentLang];
      container.appendChild(explanation);

      scenario.subsections.forEach(subsection => {
        const h3 = document.createElement('h3');
        h3.textContent = subsection.title[currentLang];
        container.appendChild(h3);

        const subExplanation = document.createElement('div');
        subExplanation.className = 'explanation';
        subExplanation.innerHTML = subsection.explanation[currentLang];
        container.appendChild(subExplanation);

        if (subsection.image) {
          const img = document.createElement('img');
          img.src = subsection.image;
          img.alt = subsection.title[currentLang];
          container.appendChild(img);
        }

        if (subsection.subsubsections) {
          subsection.subsubsections.forEach(subsubsection => {
            const h4 = document.createElement('h3');
            h4.textContent = subsubsection.title[currentLang];
            container.appendChild(h4);

            const subsubExplanation = document.createElement('div');
            subsubExplanation.className = 'explanation';
            subsubExplanation.innerHTML = subsubsection.explanation[currentLang];
            container.appendChild(subsubExplanation);

            if (subsubsection.image) {
              const img = document.createElement('img');
              img.src = subsubsection.image;
              img.alt = subsubsection.title[currentLang];
              container.appendChild(img);
            }

            container.appendChild(createTimelineTable(subsubsection.timeline));
          });
        } else {
          container.appendChild(createTimelineTable(subsection.timeline));
        }
      });
    }

    function renderAll() {
      const scenariosContainer = document.getElementById('scenarios');
      scenariosContainer.innerHTML = '';
      document.getElementById('main-title').textContent = data.title[currentLang];
      data.scenarios.forEach(scenario => renderScenario(scenario, scenariosContainer));
    }

    function switchLanguage() {
      currentLang = currentLang === 'en' ? 'vi' : 'en';
      document.getElementById('langSwitch').textContent = currentLang === 'en' ? 'Tiếng Việt' : 'Tiếng Anh';
      renderAll();
    }

    document.getElementById('langSwitch').addEventListener('click', switchLanguage);

    renderAll();

  </script>
</body>

</html>